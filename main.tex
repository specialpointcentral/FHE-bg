\documentclass[aspectratio=169]{beamer}

\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{pgfpages}

\DeclareMathOperator{\Enc}{Enc}
\DeclareMathOperator{\Dec}{Dec}

\setbeameroption{show notes on second screen=right}

\title{Background of Fully Homomorphic Encryption}
\subtitle{CKKS and TFHE}
\author{HU Qi\\PhD Student in HKU}
\institute{The University of Hong Kong}
\date{\today}

\begin{document}

\begin{frame}[plain]
  \titlepage
\end{frame}

\begin{frame}{1.1 Motivation and Definition of FHE}
  \begin{itemize}
    \item \textbf{Reality tension:} data must be ``used'' without ever being ``seen''.
    \begin{itemize}
      \item Cloud outsourcing: model inference, statistical analytics, search indexing.
      \item Regulatory pressure: GDPR, HIPAA, and cross-border data controls.
      \item Traditional encryption covers storage and transit, but requires decryption for computation.
    \end{itemize}
    \item \textbf{Privacy-computing goal:} make data usable while keeping it confidential.
    \begin{itemize}
      \item Servers only handle ciphertext yet complete the agreed computation.
      \item Clients decrypt and recover the same outcome as plaintext evaluation.
    \end{itemize}
    \item \textbf{FHE definition:} core property $\Dec(f(\Enc(x))) = f(x)$.
    \begin{itemize}
      \item Meaning: homomorphic $f$ on ciphertext, decrypt for the plaintext result.
    \end{itemize}
    \item \textbf{Typical applications:}
    \begin{itemize}
      \item Healthcare: encrypted imaging or genomics analysed in the cloud, hospitals decrypt locally.
      \item Finance: encrypted transactions scored for risk or collaborative anti-fraud.
      \item Privacy smart contracts: on-chain ciphertexts with off-chain/on-chain FHE execution.
    \end{itemize}
  \end{itemize}
  \note{Start with the question: why compute under encryption? Cloud inference, analytics, and risk scoring clash with GDPR, HIPAA, and cross-border rules that forbid revealing plaintext. Traditional encryption protects storage and transit yet forces decryption right before computationâ€”the riskiest moment. Privacy computing keeps servers on ciphertext while clients decrypt to recover the same output; the identity $\Dec(f(\Enc(x))) = f(x)$ uses the same logical $f$, with ciphertexts processed through matching homomorphic operations. FHE keeps data encrypted end-to-end, removing the server-side decrypt-compute step and shrinking leakage on untrusted infrastructure. Applications span encrypted medical AI, financial risk scoring on ciphertexts, encrypted inputs to cloud models with local decryption, and privacy smart contracts.}
\end{frame}

\begin{frame}{1.2 Evolution of Fully Homomorphic Encryption}
  \begin{itemize}
    \item 2009: Gentry's breakthrough first-generation scheme based on ideal lattices.
    \item 2011--2014: Second generation (BGV, BFV) improves efficiency via leveled FHE and bootstrapping optimizations.
    \item 2016: CKKS introduces approximate arithmetic for real-number workloads such as machine learning inference.
    \item 2016+: TFHE enables fast gate-by-gate Boolean computation with rapid bootstrapping.
    \item Current landscape: hybrid approaches, GPU acceleration, and practical libraries (HElib, SEAL, Concrete, OpenFHE).
  \end{itemize}
  \note{Here I sketch the trajectory of FHE. After Gentry's 2009 construction, leveled schemes like BGV and BFV reduced overhead. CKKS later delivered approximate arithmetic suited for ML, while TFHE focused on fast Boolean gates with efficient bootstrapping. Today the ecosystem blends these ideas, pushing toward practical deployments with optimized libraries and hardware acceleration.}
\end{frame}

\section{Mathematical Foundations of FHE}

\begin{frame}{2. Mathematical Foundations Overview}
  \begin{itemize}
    \item Modular arithmetic and polynomial rings ($\mathbb{Z}_q$, $R_q$) as the container for ciphertext addition/multiplication.
    \item Batched (SIMD) encoding intuition: one encrypted polynomial carries many data slots.
    \item Hardness assumptions from LWE/RLWE tying noisy linear equations to ring-based constructions.
  \end{itemize}
  \note{Preview the three ingredients: the modular polynomial ring container, SIMD-style batching intuition, and the LWE/RLWE hardness assumptions that secure schemes.}
\end{frame}

\begin{frame}{2.1 Modular Arithmetic and Polynomial Rings}
  \begin{itemize}
    \item Modern FHE schemes encode ciphertexts as polynomials over rings to support both addition and multiplication (ring = additive group + multiplicative semigroup).
    \item Integer modular ring: $\mathbb{Z}_q = \{0,1,\dots,q-1\}$ with addition/multiplication taken mod $q$ (typically a large prime or an RNS prime chain).
    \item Polynomial ring: $R_q = \mathbb{Z}_q[x]/(x^N+1)$ with $N$ usually a power of two.
    \begin{itemize}
      \item Elements are polynomials of degree $< N$ with coefficients in $\mathbb{Z}_q$.
      \item Multiplication: convolve coefficients, then reduce by $(x^N+1)$ so $x^N \equiv -1$.
    \end{itemize}
  \end{itemize}
  \note{Explain that FHE ciphertexts need a structure supporting both addition and multiplication, so most schemes work in polynomial rings over modular integers. First define $\mathbb{Z}_q$ with mod-$q$ arithmetic (often using large primes or RNS chains). Then show how $R_q = \mathbb{Z}_q[x]/(x^N+1)$ (with $N$ as a power of two) contains polynomials of degree less than $N$, and multiplication is implemented via convolution followed by reduction modulo $x^N+1$, effectively forcing $x^N$ to behave like $-1$.}
\end{frame}

\begin{frame}{2.2 Intuition for Batched (SIMD) Encoding}
  \begin{itemize}
    \item Goal: start from a complex vector\\
      $$z = (z_1, z_2, \dots, z_{N/2}) \in \mathbb{C}^{N/2},$$
      encode it into the CKKS ring $R_q = \mathbb{Z}_q[x]/(x^N+1)$.
    \item Observation: when $N$ is a power of two, there is an approximate isomorphism\\
      $$R_q \otimes \mathbb{C} \cong \mathbb{C}^{N/2},$$
      so one ciphertext carries $N/2$ complex slots.
    \item Practical encoding: run the complex-domain inverse DFT (discrete Fourier transform) to map slots into polynomial coefficients\\
      $$m(x) = \mathrm{Inverse\text{-}DFT}(z),$$
      then scale and round to obtain an integer polynomial $\tilde{m}(x)$ before reducing modulo $q$, so $\tilde{m}(x) \bmod q \in \mathbb{Z}_q[x]$.
  \end{itemize}
  \note{Explain that batching in CKKS means taking a complex vector $z$ and embedding it into the polynomial ring. The key fact is the approximate isomorphism $R_q \otimes \mathbb{C} \cong \mathbb{C}^{N/2}$ when $N$ is a power of two; hence each ciphertext holds $N/2$ complex slots. Practically we run an inverse DFT on $z$ in the complex domain to produce $m(x)$, then scale and round to an integer polynomial $\tilde{m}(x)$ and reduce modulo $q$ so it lives in $\mathbb{Z}_q[x]$ before encryption.}
\end{frame}

\begin{frame}{2.3 LWE and RLWE}
  \begin{itemize}
    \item Motivation: Learning With Errors (LWE) and Ring-LWE (RLWE) provide computationally controllable, provably secure public-key and homomorphic encryption foundations.
    \item Core idea: add random noise to hide plaintexts while preserving ring/polynomial structure for computation, reducing security to GapSVP (quantum-resistant).
    \item LWE (vector form): samples $(A, b = A s + e \bmod q)$ where $A$ is random, $s$ secret, $e$ small noise.
    \item RLWE (polynomial form): samples $(a(x), b(x) = a(x) s(x) + e(x) \bmod q)$ over $R_q$.
    \item Transition: RLWE inherits LWE hardness while enabling structured polynomials that FHE schemes rely on.
  \end{itemize}
  \note{Introduce why we need LWE/RLWE: they add controlled random noise to hide plaintexts while preserving the ring/polynomial structure needed for computation, with security reducible to GapSVP even against quantum adversaries. Briefly define LWE via noisy linear equations $b = As + e \pmod{q}$ and RLWE via polynomial samples $b(x) = a(x)s(x)+e(x) \pmod{q}$ inside $R_q$. Emphasize that RLWE inherits LWE hardness yet aligns with the polynomial ring container used in FHE, enabling efficient and analyzable homomorphic schemes.}
\end{frame}

\begin{frame}{2.4 LWE: $b = A s + e \pmod{q}$ Hardness}
  \begin{itemize}
    \item Content to be added.
  \end{itemize}
  \note{Content to be added.}
\end{frame}

\begin{frame}{2.5 RLWE: $b(x) = a(x) s(x) + e(x)$}
  \begin{itemize}
    \item Content to be added.
  \end{itemize}
  \note{Content to be added.}
\end{frame}

\end{document}
